'use strict';
// SPDX-License-Identifier: AGPL-3.0-or-later
// Based on original mwan3 by Florian Eckert <fe@dev.tdt.de>

import { popen, readfile } from 'fs';
import { cursor } from 'uci';

const ubus = require('ubus').connect();

function get_str_raw(iface, property) {
	return readfile(sprintf('/var/run/mwan4track/%s/%s', iface, property));
}

function get_str(iface, property) {
	return rtrim(get_str_raw(iface, property), '\n');
}

function get_int(iface, property) {
	return int(get_str(iface, property));
}

function get_connected_ips(version) {
	// Check if nftables set exists
	const nftflag = (version == '4') ? 'ip' : 'ip6';
	const check = popen(sprintf('nft list set inet fw4 mwan4_connected_ipv%s 2>/dev/null', version), 'r');
	const output = check.read('all');
	check.close();

	if (!length(output)) {
		return [];
	}

	// Extract IPs from nftables set
	const ips = [];
	const lines = split(output, '\n');
	let in_elements = false;
	for (let line in lines) {
		line = trim(line);
		if (match(line, /elements = \{/)) {
			in_elements = true;
			continue;
		}
		if (in_elements && match(line, /\}/)) {
			break;
		}
		if (in_elements && length(line) > 0) {
			// Remove trailing comma and whitespace
			line = replace(line, /[,\s]+$/, '');
			if (length(line) > 0) {
				push(ips, line);
			}
		}
	}
	return ips;
}

function get_policies(version) {
	const nftflag = (version == '4') ? 'ipv4' : 'ipv6';
	const nft = popen('nft -a list chains inet fw4 2>/dev/null', 'r');
	const policies = {};

	// First get list of policy chains
	const policy_chains = [];
	for (let line = nft.read('line'); length(line); line = nft.read('line')) {
		const m = match(line, /chain mwan4_policy_([^_]+)_(ipv4|ipv6)/);
		if (m != null && m[2] == nftflag) {
			push(policy_chains, m[1]);
		}
	}
	nft.close();

	// Now get details for each policy chain
	for (let policy in policy_chains) {
		const chain_name = sprintf('mwan4_policy_%s_%s', policy, nftflag);
		const chain = popen(sprintf('nft list chain inet fw4 %s 2>/dev/null', chain_name), 'r');
		policies[policy] = [];

		for (let line = chain.read('line'); length(line); line = chain.read('line')) {
			// Match: meta mark & 0x3f00 == 0 meta mark set 0x0300 comment "wan 3 3"
			const m = match(line, /comment "([^ ]+) ([0-9]+) ([0-9]+)"/);
			if (m != null) {
				const intfw = m[1];
				const weight = int(m[2]);
				const total = int(m[3]);
				if (weight >= 0 && total > 0) {
					push(policies[policy], {
						'interface': intfw,
						'percent': weight / total * 100,
					});
				}
			}
		}
		chain.close();
	}

	return policies;
}

function interfaces_status(request) {
	function get_uptime() {
		return int(split(readfile('/proc/uptime'), '.', 2)[0]);
	}

	function get_x_time(uptime, iface, property) {
		let t = get_int(iface, property);
		if (t > 0) {
			t = uptime - t;
		}
		return t;
	}

	function ucibool(val) {
		switch (val) {
			case 'yes':
			case 'on':
			case 'true':
			case 'enabled':
				return true;
			default:
				return !!int(val);
		}
	}

	function get_mwan4track_status(iface, uci_track_ips, procd) {
		if (length(uci_track_ips) == 0) {
			return 'disabled';
		}
		if (procd?.[sprintf('track_%s', iface)]?.running) {
			const started = get_str(iface, 'STARTED');
			switch (started) {
				case '0':
					return 'paused';
				case '1':
					return 'active';
				default:
					return 'down';
			}
		}
		return 'down';
	}

	const uci = cursor();
	const procd = ubus.call('service', 'list', { 'name': 'mwan4' })?.mwan4?.instances;
	const interfaces = {};
	uci.foreach('mwan4', 'interface', intf => {
		const ifname = intf['.name'];
		if (request.args.interface != null && request.args.interface != ifname) {
			return;
		}
		const netstatus = ubus.call(sprintf('network.interface.%s', ifname), 'status', {});
		const uptime = get_uptime();
		const uci_track_ips = intf['track_ip'];
		const track_status = get_mwan4track_status(ifname, uci_track_ips, procd);
		const track_ips = [];
		for (let ip in uci_track_ips) {
			push(track_ips, {
				'ip': ip,
				'status': get_str(ifname, sprintf('TRACK_%s', ip)) || 'unknown',
				'latency': get_int(ifname, sprintf('LATENCY_%s', ip)),
				'packetloss': get_int(ifname, sprintf('LOSS_%s', ip)),
			});
		}
		interfaces[ifname] = {
			'age': get_x_time(uptime, ifname, 'TIME'),
			'online': get_x_time(uptime, ifname, 'ONLINE'),
			'offline': get_x_time(uptime, ifname, 'OFFLINE'),
			'uptime': netstatus?.uptime || 0,
			'score': get_int(ifname, 'SCORE'),
			'lost': get_int(ifname, 'LOST'),
			'turn': get_int(ifname, 'TURN'),
			'status': get_str(ifname, 'STATUS') || 'unknown',
			'enabled': ucibool(intf['enabled']),
			'running': track_status == 'active',
			'tracking': track_status,
			'up': netstatus?.up || false,
			'track_ip': track_ips,
		};
	});
	return interfaces;
}

function status_call(request) {
	switch (request.args.section) {
		case 'connected':
			return {
				'connected': {
					'ipv4': get_connected_ips('4'),
					'ipv6': get_connected_ips('6'),
				},
			};
		case 'policies':
			return {
				'policies': {
					'ipv4': get_policies('4'),
					'ipv6': get_policies('6'),
				},
			};
		case 'interfaces':
			return {
				'interfaces': interfaces_status(request),
			};
		default:
			return {
				'interfaces': interfaces_status(request),
				'connected': {
					'ipv4': get_connected_ips('4'),
					'ipv6': get_connected_ips('6'),
				},
				'policies': {
					'ipv4': get_policies('4'),
					'ipv6': get_policies('6'),
				},
			};
	}
}

const methods = {
	status: {
		args: {
			section: 'section',
			interface: 'interface'
		},
		call: status_call
	}
};

return { 'mwan4': methods };
