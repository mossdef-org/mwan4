'use strict';
// SPDX-License-Identifier: AGPL-3.0-or-later
// Copyright 2026 MOSSDeF, Stan Grishin (stangri@melmac.ca).
// Based on original mwan3 by Florian Eckert <fe@dev.tdt.de>

push(REQUIRE_SEARCH_PATH, '/lib/mwan4/*.uc');
import m from 'mwan4';

m.set_scriptname('rpcd-mwan4');
m.init();

function get_strategies(family) {
	let data = m.get_strategies_data(family);
	let result = {};
	for (let name in keys(data)) {
		result[name] = [];
		for (let e in data[name]) {
			if (e.total > 0)
				push(result[name], {
					'interface': e.iface,
					'percent': e.weight / e.total * 100,
				});
		}
	}
	return result;
}

function interfaces_status(request) {
	let uptime = m.get_uptime();
	let procd = m.ubus_call('service', 'list', { 'name': 'mwan4' })?.mwan4?.instances;
	let interfaces = {};

	m.uci_foreach('interface', function(intf) {
		let ifname = intf['.name'];
		if (request.args.interface != null && request.args.interface != ifname)
			return;

		let families = m.get_families(ifname);
		let primary_si = ifname + '_' + (families[0] || 'ipv4');

		let netstatus = m.ubus_call(sprintf('network.interface.%s', ifname), 'status');
		let uci_track_ips = intf['track_ip'];
		let track_status;

		if (!length(uci_track_ips)) {
			track_status = 'disabled';
		} else if (procd?.[sprintf('track_%s', primary_si)]?.running) {
			let started = m.read_str(sprintf('%s/%s/STARTED', m.TRACK_STATUS_DIR, primary_si)) || '';
			switch (started) {
				case '0': track_status = 'paused'; break;
				case '1': track_status = 'active'; break;
				default:  track_status = 'down'; break;
			}
		} else {
			track_status = 'down';
		}

		let track_ips = [];
		for (let ip in uci_track_ips) {
			push(track_ips, {
				'ip': ip,
				'status': m.read_str(sprintf('%s/%s/TRACK_%s', m.TRACK_STATUS_DIR, primary_si, ip)) || 'unknown',
				'latency': m.read_int(sprintf('%s/%s/LATENCY_%s', m.TRACK_STATUS_DIR, primary_si, ip)),
				'packetloss': m.read_int(sprintf('%s/%s/LOSS_%s', m.TRACK_STATUS_DIR, primary_si, ip)),
			});
		}

		// Aggregate STATUS across families: online if any family is online
		let overall_status = 'unknown';
		for (let family in families) {
			let si = ifname + '_' + family;
			let st = m.read_str(sprintf('%s/%s/STATUS', m.TRACK_STATUS_DIR, si)) || 'unknown';
			if (st == 'online') { overall_status = 'online'; break; }
			if (st == 'offline') overall_status = 'offline';
		}

		interfaces[ifname] = {
			'age': uptime - m.read_int(sprintf('%s/%s/TIME', m.TRACK_STATUS_DIR, primary_si)),
			'online': uptime - m.read_int(sprintf('%s/%s/ONLINE', m.TRACK_STATUS_DIR, primary_si)),
			'offline': uptime - m.read_int(sprintf('%s/%s/OFFLINE', m.TRACK_STATUS_DIR, primary_si)),
			'uptime': netstatus?.uptime || 0,
			'score': m.read_int(sprintf('%s/%s/SCORE', m.TRACK_STATUS_DIR, primary_si)),
			'lost': m.read_int(sprintf('%s/%s/LOST', m.TRACK_STATUS_DIR, primary_si)),
			'turn': m.read_int(sprintf('%s/%s/TURN', m.TRACK_STATUS_DIR, primary_si)),
			'status': overall_status,
			'enabled': m.uci_bool(intf['enabled']),
			'running': track_status == 'active',
			'tracking': track_status,
			'up': netstatus?.up || false,
			'track_ip': track_ips,
		};
	});
	return interfaces;
}

function status_call(request) {
	switch (request.args.section) {
		case 'connected':
			return {
				'connected': {
					'ipv4': m.report_connected('ipv4'),
					'ipv6': m.report_connected('ipv6'),
				},
			};
		case 'strategies':
			return {
				'strategies': {
					'ipv4': get_strategies('ipv4'),
					'ipv6': get_strategies('ipv6'),
				},
			};
		case 'interfaces':
			return {
				'interfaces': interfaces_status(request),
			};
		default:
			return {
				'interfaces': interfaces_status(request),
				'connected': {
					'ipv4': m.report_connected('ipv4'),
					'ipv6': m.report_connected('ipv6'),
				},
				'strategies': {
					'ipv4': get_strategies('ipv4'),
					'ipv6': get_strategies('ipv6'),
				},
			};
	}
}

const methods = {
	status: {
		args: {
			section: 'section',
			interface: 'interface'
		},
		call: status_call
	}
};

return { 'mwan4': methods };
